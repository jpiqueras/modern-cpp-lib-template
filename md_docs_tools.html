<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>modern-cpp-lib-template: Using the tools</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">modern-cpp-lib-template
   &#160;<span id="projectnumber">1.0.1</span>
   </div>
   <div id="projectbrief">Modern C++ template</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_docs_tools.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Using the tools </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Here you can find a more detailed description of each tool and some tips on how to use them. If you want practical examples on how to use them, check the tool documentation and the <a class="el" href="md_docs_cicd.html">CI workflows</a>.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Code formatting tools</h1>
<p>As the name suggests, these tools format the code to follow pre-configured standard rules, so there is no need to worry about spacing, line length, new lines, etc. They perform very basic tests that should not alter the code that the compiler sees. So, for example, these tools would not reorder the <code>#include</code> statements. Because of that, ideally you should configure your IDE to apply the format upon saving.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
clang-format</h2>
<p>The format rules are configured in the root file <code>.clang-format</code>. Currently, the Google style is being used.</p>
<p>Most IDEs will dected the <code>.clang-format</code> file and automatically format the code. In <code>VS Code</code> this is done by the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C++ extension</a>. Just by having the extension it should work, but it can be configured in the <code>Formatting</code> section of the extension settings. You can also run manually the command <code>Format Document</code> from the command palette to format the file.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Static analysis tools</h1>
<p>Static analysis tools perform more complex checks than formatting tools, but they also take longer to analyze and can yield many false positives. I would recomment to run the analysis everytime upon saving or opening the files if your pc can handle it.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
clang-tidy</h2>
<p>The checks are specified in the <code>.clang-tidy</code> file. Right now basically checking for everything except some specific rules for other projects or annoying checks like using auto return trailing types. The <code>.clang-tidy</code> is also configured to enforce the naming conventions I prefer. In <code>VS Code</code> clang-tidy is automatically available with the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C++ extension</a>. It is under the <code>Code Analysis</code> settings, and it can be run automatically when saving or for example invoked through the command palette through <code>Run Code Analysis</code> in the active or in all the files. In order for the extension to check your header files (very important in header-only libraries), VS Code should call <code>clang-tidy</code> with the <code>--header-filter="*"</code> option. Check the <a class="el" href="md_docs_configuring.html">Configuration for VS Code section</a> for more details.</p>
<p>There is also a custom option in CMake, and configurable through Conan, to create a CMake target to run clang-tidy. This target is only available in Linux (even when setting the option to True in Windows systems). This is because in Windows it is a bit more difficult to configure the run, and in the end the tool is available through the VS Code C++ extension. You can check the <code>Tools.cmake</code> file to see how the target is configured, and the <code>code-checks.yml</code> workflow to see how to create and invoke the target through the command line. Because in the end it is another CMake target, it can be invoked directly from the CMake VS Code extension, and the code will be linted automatically.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
cpplint</h2>
<p>cpplint is in between a formatting and a static analysis tool. The rules are configured in the <code>CPPLINT.cfg</code> file. In <code>VS Code</code> you can use it just by installing the <a href="https://marketplace.visualstudio.com/items?itemName=QiuMingGe.cpp-check-lint">cpp-check-lint extension</a> The extension will check and lint the code automatically when saving, but it can be configured. The extension also includes the <code>cppcheck</code> tool.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
cppcheck</h2>
<p>cppcheck is a static analysis tool that detects errors and vulnerabilities in C and C++ code. It can identify memory leaks, buffer overruns, and other issues that might cause crashes or undefined behavior. In VS Code, you can use it by installing the <a href="https://marketplace.visualstudio.com/items?itemName=QiuMingGe.cpp-check-lint">cpp-check-lint extension</a>. The extension will check the code automatically when saving, but it can be configured. The extension also includes the cpplint tool.</p>
<p>Similar as with <code>clang-tidy</code> there is a <code>cppcheck</code> target for CMake to check all the relevant files of the library. The target is configured in the <code>CMakeLists.txt</code> file under the <code>test</code> directory. If you look at the target configuration, you can see that some files are excluded to avoid false positives. If you use <code>cppcheck</code> manually or through VS Code (see <a class="el" href="md_docs_configuring.html">Configuration for VS Code section</a>), you might want to exclude also those files.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
CodeQL</h2>
<p>CodeQL is a code analysis engine developed by GitHub that can analyze source code to identify security vulnerabilities, bugs, and maintainability issues. CodeQL supports multiple languages, including C and C++. The CodeQL workflow is in the one responsible to do the test. In principle, I think it is not necessary to have a local CMake target or VS Code to run CodeQL. If the workflow fails in some commits, just fix the code.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Testing tools</h1>
<h2><a class="anchor" id="autotoc_md13"></a>
Catch2</h2>
<p>C++ library for unit testing. It integrates easily with CTest (CMake own test coordinator tool). In this template, everything related to the tests is under the <code>./test</code> folder. When the folder is included from the root <code>CMakeLists</code> using the <code>add_subdirectory</code> command, a <code>tests</code> target (and the clang-tidy and cppcheck targets if the options are activated) is made available.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Code coverage</h2>
<p>Code coverage is a metric used in software testing to measure the extent to which the source code of a program has been executed by a test suite. It is expressed as a percentage, representing the ratio of the number of lines, branches, functions, or statements in the code that have been tested to the total number of lines, branches, functions, or statements.</p>
<p>Here, we use <code>gcov</code>, <code>lcov</code> and <a href="https://codecov.io/">Codecov</a>. Check the <code>coverage</code> workflow and the <code>coverage</code> CMake target for more info.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Documentation</h1>
<h2><a class="anchor" id="autotoc_md16"></a>
Doxygen + graphviz + Doxygen Awesome CSS</h2>
<p>Doxygen is a popular documentation generation tool for C++ code and it generates documentation from source code comments in a variety of formats, including HTML, LaTeX, and more. You can use it with <code>Graphviz</code> to also generate relationship diagrams of the classes. The default theme of doxygen is a bit outdated, so you can use CSS templates such as <a href="https://github.com/jothepro/doxygen-awesome-css">Doxygen Awesome</a> to make it much better.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Package managers: Conan</h1>
<p>I've decided to use <code>Conan</code> as the package manager for the library, see the note below on why. Conan can do many other things than just managing the external dependencies and because Conan is now a mandatory tool, it makes sense to use other features it can offer. Specifically, we are using Conan to manage external dependencies, setup the build chain, to set the package version, and to configure the package options.</p>
<p>The options related to the package itself and its dependencies is configured within the <code>conanfile.py</code>. The build tools (compiler, C++ standard, build type) are managed in conan using profiles.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
conanfile.py</h2>
<p>There are many options configured in the <code>conanfile.py</code> file, here are some of them:</p>
<ul>
<li>version: This is the only place where the version is defined. The version defined here is propagated to CMake and from CMake to the source code.</li>
<li>options and default_options: The options of the package that will be passed to CMake.</li>
</ul>
<p>For more details check the <code>conanfile.py</code> file in the root directory and the <a href="https://docs.conan.io/2/reference/conanfile.html">conan documentation</a>.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Conan profiles</h2>
<p>There are several files (profiles) under <code>.conan/profiles</code> that are used to configure the build for the CI/CD operations in the Github Workflows. There are three types of profile files in that folder:</p><ol type="1">
<li>Profiles starting with the <code>os</code> name For example, <code>windows-msvc2022-amd64</code> or <code>ubuntu-gcc12-amd64</code>. These profiles specify the required operative system and compiler to build the package. They set the options <code>[buildenv]</code> so CMake will raise and error during the configuration stage if the specified compiler is not found. Otherwise it will try to use another. <em>Note:</em> Now msvc is configured with <code>dynamic</code> runtime. It also can be <code>static</code>.</li>
<li><p class="startli">Profiles starting with <code>build-</code> Set the <code>build-type</code> during the configuration and build stages. The name of the CMake build preset created by conan will match the build type. For example, if a <code>Release</code> build has been selecte, the build preset will be called <code>conan-release</code>.</p>
<p class="startli">The name of the CMake configure preset is always <code>conan-default</code> despite of the build type. However, just in case, the <code>-DCMAKE_BUILD_TYPE=&lt;build_type&gt;</code> is passed to CMake. You can install the package for <code>Release</code> and <code>Debug</code> mode at the same time, and you will have two preset to build the library but only one configure preset. See Issue #26</p>
</li>
<li>Profiles starting with <code>options-</code> These are options to configure the package, for example to select if you want to build or not the docs.</li>
</ol>
<p>When calling <code>conan install</code> or <code>conan create</code> you can specify several profiles that will be combined. In the CI/CD workflows I combine the three previous types depending on the workflow. You are free to use those profiles as they are used in the CI workflows, but probably, the more convenient way build the package locally is to configure the <code>default</code> profile in you system.</p>
<p>To do so, use <code>conan profile detect --force</code> to generate the <code>default</code> profile. Then, open the generated file and change the options as you want. You should also add the options for the package. This is explained in the Check the</p>
<p>For more info about the options in the profiles see: <a href="https://docs.conan.io/2/reference/config_files/settings.html">https://docs.conan.io/2/reference/config_files/settings.html</a></p>
<h2><a class="anchor" id="autotoc_md20"></a>
Note on vcpkg vs conan</h2>
<p>The most standard package managers are <a href="https://vcpkg.io">vcpkg</a> and <a href="https://conan.io/">conan</a>. At the begining I chose to use <code>vcpkg</code> because it seems easier to use and doesn't required additional dependencies. You can use vcpkg directly from CMake by fetching the repository and setting it as the CMake toolchain before calling <code>projec()</code>. This approach works fine for building the executable/library directly without <em>consuming</em> it from another project.</p>
<p>However, when trying to use <code>my_lib</code> from an external project (another C++ project or when building a <code>pybind11</code> module) with its dependencies managed by vcpkg, it turn out to be not so simple. There are several approaches to follow, I managed to make it work by setting the same dependencies in the <em>external project</em> as in <code>my_lib</code>, but that means duplicate dependencies definition and several obscure workarounds. In the end, if I understood how to use vcpkg correctly, you would need to create a proper package of <code>my_lib</code> and then consume it normally with <code>find_package()</code> with or without using vcpkg in the external project. And to properly do all of this, it is necessary to undertand how vcpkg works in detail, how <code>CMake</code> and the <code>install()</code> and <code>find_package()</code> works in detail, and the advantage of managing everything from CMake is lost.</p>
<p>Because of that I went back to <code>conan</code>. I didn't try conan at the beginning because it seems more difficult, you need to set-up python and a python environment, cmake accesible from the command line and invoke all of this externally to CMake. Make it all of this to work automatically in windows and linux and in Github Workflows seems to me very difficult, but it was really not the case when looking at it. Set-up python is really easy in Github, and by using python you can do many other things easily, like running the formatting and analysis tools or install CMake using pip. And for building python extensions I need to set-up python anyway. But the most important thing for me, is that <code>conan</code> can be used to configure every aspect of the build and installation process from python with the 'conanfile.py'. Which in the end means that you can use high-level functions (many of them already built by conan) to configure CMake without writting cmake code. For me, that I find python <em>comfortable</em> but CMake seems really difficult to use, is the ideal package manager.</p>
<p>By using <code>conan</code> I've started to move build and installation logic from the <code>CMakeLists.txt</code> files and <code>*.cmake</code> scripts to the <code>conanfile.py</code>. If I find <code>conan</code> to work well, I will continue to move many of the packaging, build and compilation logic to the <code>conanfile.py</code>. The goal would be then to simplify CMake code and leave all the build and compilation stuff to conan.</p>
<p>TL;DR: <code>vcpkg</code> is easier to use for simple projects and doesn't requiere external dependencies besides CMake. <code>conan</code> needs python, but you can move build and packaging CMake code to python, which makes it easier for me. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
